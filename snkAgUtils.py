# -*- coding: utf-8 -*-
"""
Created on Mon Sep 10 19:40:05 2018

@author: Paulo Augusto
"""

    

import numpy as np
#from numpy import fft
import matplotlib.pyplot as plt
#import scipy.signal as sig
import os
import random 
import threading
import multiprocessing

                    # This script is compatible with 'emgReaderClass_v2', that
                    # reads the .csv files generated by 'movementSaver.m', from
                    # the folder './csv/'
    
bias=0              # If bias = 1, every cromossome will have a non frequency dependant DNA
maxGen=10000         # The max number of generations
startOver=False# If True, the code will not consider the last simulation
tamPop=500          # Population number

maxFreq=180        # This is the max Frequency to consider #240
freqStep=3         # For freqStep=3 -> The code will consider [1,2,3],[3,4,5], etc# 3

taxaMut=0.01        # The mutation rate
taxaMutMin=0.01     # Minimum mutation rate
taxaMutMax=20.0     # Maximum mutation rate
chanceMut=50        # The chance of mutation/10000 (only for the "absolute" mutation)

bestTypes=[]        # Logging variable

continuous=False    # If True, the code will use a continuous fitness function (not recommended)
binaryFit=True     # If True, the fitness of each individual will be 1 for each right guess
                    # If False, it will be continuous if "continuous" is True, or 1 point if
                    # it guesses correctly, and 1.5 if it guesses with an confidence above 
                    # a "multFac" threshold
multFac=1.5         # 
binaryCrossChance=0.5           # The chance of ocurring a binary cross. 1 minus this 
                                # is the chance of ans mean crossing
vectorialMutationChance=0.5     # The chance of vectorial mutation. 1 minus this is 
                                # chance of an absolute mutation

taxaMutMult=4.0                 # The factor by which taxaMut will be multiplied
initialModule=1                # Initial module of cromossome values

sourceType='ninapro'
fs=2000
##############################################################################
guid=0                          # Individual ID (logging variable)

real=[]                         # DATA
origin=[]                       # DATA
fv=[]                           # DATA
frv=[]                          # DATA
nArq=0                          # DATA


# lastValues, botThs and topThs to be used in each archive
parameters={'bicepsinteiro.txt': [400,20,10],\
            'bicepsmetade.txt': [400,20,10],\
            'emgwk.txt': [400,20,10],\
            'emgmed.txt':[400,20,10],\
#            'xoxoxo.txt':[300,40,30],\
            'emgabrindo.txt':[500,20,20],\
            'emgapertando.txt':[400,20,20]}
    

def mergeSnakes(snk1,snk2):
    snk=tksnake.snake(lenght=snk1.lenght,width=snk1.width,segDis=snk1.segDis)
    snk.brainMatrixes=(snk1.brainMatrixes+snk2.brainMatrixes)/2
    
# Crossover by adding different chromossomes and dividing by the number of
# fathers
def meanCrossover(pais):
    
    filho= tknake.snake(pais[0].root,x=0,y=0,lenght=pais[0].lenght,width=pais[0].width,segDis=pais[0].segmentDistance)
    
    soma = sum([pai.brainMatrixes for pai in pais])
    
    tam= len(pais)
    filho.brainMatrixes=somaFreqs/tam
    mutate(filho)
    filho.marker+=' meaned '
    
    return filho

# Crossover by replacing the sons genes by his mother's or his father's, with 
# 50% chance
def binaryCrossover(pais):
    filho=tknake.snake(pais[0].root,x=0,y=0,lenght=pais[0].lenght,width=pais[0].width,segDis=pais[0].segmentDistance)
    for i in range(0,len(filho.brainMatrixes)):
        for j in range(0,len(filho.brainMatrixes[i])):
            for k in range(0,len(filho.brainMatrixes[i][j])): 
                if random.random()<0.5:
                    filho.brainMatrixes[i][j,k]=pais[0].brainMatrixes[i][j,k]
                else:
                    filho.brainMatrixes[i][j,k]=pais[1].brainMatrixes[i][j,k] 
    mutate(filho)
    filho.marker+=' binerized '                  
    return filho          

# Mixed crossover
def weightedCrossover(pais):
    if random.random()<binaryCrossChance:
        return binaryCrossover(pais)
    else:
        return meanCrossover(pais)

# Tournament. Returns the best fitted individual
def torneio(snkry):
    
    snkry.run()
    bestIndiv=snkry.best

    return bestIndiv
        
# Generate a new population by performing crossovers with best and the reminder
# population
def genNewPop(best,pop):   
    for indiv in pop.population:
        if indiv == best:
#            newpop.population.append(indiv)
            continue
        else:
            temp=weightedCrossover([best,indiv])
            indiv=temp
    return newpop

# Remove the n less fitted individuals, replacing them by new ones
def removeSuckers(pop,n):
    
    def getFit(indiv):
        return indiv.fit
    pop.population.sort(reverse=False,key=getFit)
    snk1=pop.poulation[0]
    for i in range(0,n):
        pop.population[i]=tksnake.snake(lenght=snk1.lenght,width=snk1.width,segDis=snk1.segDis)
        pop.population[i].marker+= 'new'
        
# Returns the mean fitness of poppulation in pop
def getPopMean(pop):
    temp=0.0
    tam=len(pop.population)
    for indiv in pop.population:
        temp+=indiv.fit
    return temp/tam
    
# Plot a graph
def plotGens(best,mean):
    plt.plot(best,'go')
    plt.plot(mean,'b-')

# Class for controlling the GA variables
class populationControl():
    global  tamPop,\
            taxaMut,\
            chanceMut,\
            bestAll,\
            bias,\
            maxGen,\
            tamPop,\
            taxaMut,\
            taxaMutMax,\
            chanceMut,\
            continuous,\
            binaryFit,\
            multFac,\
            binaryCrossChance,\
            taxaMutMult,\
            taxaMutMin

    def __init__(self):
        self._tamPop=tamPop
        self._taxaMut=taxaMut
        self._chanceMut=chanceMut
        self._bias=bias
        self._maxGen=maxGen
        self._tamPop=tamPop            
        self._taxaMutMin=taxaMutMin
        self._taxaMutMax=taxaMutMax
        self._chanceMut=chanceMut
        self._continuous=continuous
        self._binaryFit=binaryFit
        self._multFac=multFac
        self._binaryCrossChance=binaryCrossChance
        self._taxaMutMult=taxaMutMult
        self._counter=0
        self._expansion=False
  
    def control(self,gen,counter,best,last):
        global taxaMut
#        taxaMut=self._taxaMutMax
        ascendingCounter=0
        if gen>25:
            if best.fit<=last.fit*1.001: #If the fitness doesnt grow by 0.1%
                self._counter+=1
            else:
                chanceMut=self._chanceMut
                self._expansion=False
                self._counter=0
                ascendingCounter=0
                
            
            if self._counter==10:    # If the fitness doesnt grow in n generations
                if self._expansion: # If it the taxaMut is increasing 
                    if taxaMut<self._taxaMutMax:    # If taxaMut is less than the maximum
                        taxaMut*=self._taxaMutMult
                    else:           # If taxaMut bigger than the maximum
                        self._expansion=False
    
                else:               # If taxaMut is decreasing
                    if taxaMut>self._taxaMutMin:    # If it is bigger than the minimum
                        taxaMut/=self._taxaMutMult
                    else:                           # If it is less than the minimum
                        self._expansion=True    
                
                self._counter=0  


# Mutation method. The mutation can be vetorial or absolute.
def mutate(indiv):

    global taxaMut,chanceMut

    if random.random()<vectorialMutationChance:
        vec=tknake.snake(indiv.root,x=0,y=0,lenght=indiv.lenght,width=indiv.width,segDis=indiv.segmentDistance).brainMatrixes
  
        for indivLayer,layer in zip(indivLayer.brainMatrixes,vec.brainMatrixes):
            
            amp=np.sqrt(sum([sum([pow(i,2) for i in line])  for line in layer]))
            layer/=amp
    #        vec*=taxaMut*random.random()
            layer*=taxaMut
    #        for value in vec.A1:
    #            value*=taxaMut
            indivLayer+=layer
        indiv.marker='vectorial'
#    for line in indiv.cromo.freqFactor:
#        for i in range(0,len(np.array(line)[0])):
#            if random.random()*1000<chanceMut:
#                line[0,i]+=mut*random.random()
    else:
        for layer in indiv.brainMatrixes:
            for line in layer:
                for value in line:    
                    if random.random()*10000<chanceMut:
                        if random.random()<0.5:
                            mut =  taxaMut
                        else:
                            mut = -taxaMut
                        value+=mut*random.random()
    
        indiv.marker='absolute'
        
#def main():
#    
#    global  maxFreq,\
#            freqStep,\
#            tamPop,\
#            taxaMut,\
#            chanceMut,\
#            nArq,\
#            bestAll,\
#            startOver,\
#            bestTypes
#                    
#    gen=0
#    counter=0
#    last=ind()
#    bestVec=[]
#    meanVec=[]
#    taxaVec=[]
#    taxaMut=taxaMutMax
#
#
#
##    plotter=dataPlotter.dataPlotter('Geracao','Melhor de Todos',bestVec)
##    threading.Thread(target=plotter.start).start()
#    controller=populationControl()
#    readArqs(sourceType)
#    if sourceType=='bioplux':
#        nArq=len(getArqs())
#    elif sourceType=='ninapro':
#        nArq=len(real)
#    else:
#        1
#        
#    if startOver:
#        pop = population()
#        pop.initPop(tamPop)
#    else:
#        print 'Didnt start over'
#        pop=bestAll
#    while gen<maxGen:
#        gen+=1
#        pop.evaluateAll()
#        best=torneio(pop)
#        
#        if not last.uid==best.uid:
#            bestTypes.append(best.marker)
#            
#        print(gen,best.fit,':',best.marker,tamPop,taxaMut,chanceMut,maxGen)#,':', [p.fit for p in population]
#        pop=genNewPop(best,pop)
#    ###########################################################################
#        controller.control(gen,counter,best,last)
#        last=best
#        
#        taxaVec.append(20*np.log(taxaMut))
#        bestVec.append(last.fit)
#        meanVec.append(getPopMean(pop))
#    ###########################################################################
##        createSuckers(pop.tamPop/3)
#        removeSuckers(pop,tamPop/3)
##        normalizePop(pop)
#    
#    plotGens(bestVec,meanVec)
#    plotGens(bestVec,taxaVec)
#    pop.evaluateAll()
#    print([p.fit for p in pop.population])
#    
#    return pop
    
    